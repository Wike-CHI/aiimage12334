# 任务管理机制分析与重构方案

## 文档概述

**项目**: 白底图生成器（AI Image Generator）  
**当前版本**: v1.1.0  
**分析日期**: 2026-01-08  
**作者**: AI Assistant

---

## 一、现状分析

### 1.1 当前架构概览

项目目前**已部分实现 WebSocket**，但仍然保留了 HTTP 轮询作为补充机制：

#### 后端架构
- **主框架**: FastAPI + Python
- **任务队列**: 自定义 `TaskQueue` 类（单例模式）
- **WebSocket 管理**: `ConnectionManager` 类（单例模式）
- **数据库**: SQLAlchemy + SQLite/PostgreSQL
- **异步处理**: ThreadPoolExecutor（4个工作线程）

#### 前端架构
- **主框架**: React + TypeScript
- **状态管理**: React Hooks
- **WebSocket**: 全局 `WebSocketContext` + `useWebSocket` hook
- **HTTP 客户端**: Axios（用于任务查询）

### 1.2 现有 WebSocket 实现分析

#### 后端实现（已完成）

**文件**: `backend/app/services/websocket_manager.py`

```python
class ConnectionManager:
    """单例 WebSocket 连接管理器"""
    
    # 用户连接映射: user_id -> Set[WebSocket]
    active_connections: Dict[int, Set[WebSocket]]
    
    # 反向映射: WebSocket -> user_id
    connection_users: Dict[WebSocket, int]
    
    async def connect(websocket, user_id)
    def disconnect(websocket, user_id)
    async def send_personal_message(message, user_id)
    async def broadcast_task_update(user_id, data)
    async def broadcast_task_complete(user_id, task_id, data)
    async def broadcast_task_failed(user_id, task_id, error_message)
```

**WebSocket 端点**: `/ws/notifications?token=<jwt_token>`

**消息格式**:
```json
{
  "type": "task_update|task_complete|task_failed",
  "task_id": 123,
  "data": {
    "status": "processing|completed|failed",
    "progress": 0-100,
    "result_image_url": "...",
    "elapsed_time": 1.5,
    "estimated_remaining_seconds": 30,
    "error_message": "...",
    "updated_at": "2026-01-08T10:00:00"
  }
}
```

#### 前端实现（已完成）

**文件**: `src/context/WebSocketContext.tsx`

```typescript
interface WebSocketContextValue {
  isConnected: boolean;
  lastMessage: WebSocketMessage | null;
  subscribe: (taskId: number, callbacks) => unsubscribe;
  unsubscribe: (taskId: number) => void;
  unsubscribeAll: () => void;
}
```

**特性**:
- ✅ 全局单例连接
- ✅ 自动重连（指数退避）
- ✅ 心跳保活（30秒间隔）
- ✅ 订阅/发布模式
- ✅ 多任务监听支持

### 1.3 HTTP 轮询现状

#### 轮询点1：任务历史列表

**文件**: `src/hooks/useTaskHistory.ts`

```typescript
useEffect(() => {
  if (autoRefresh || !isConnected) {
    intervalRef.current = setInterval(() => {
      fetchTasks();  // 每5秒轮询一次
    }, 5000);
  }
}, [user, autoRefresh, isConnected]);
```

**问题**:
1. 即使 WebSocket 已连接，`autoRefresh=true` 时仍会轮询
2. 5秒间隔对于快速变化的任务队列响应较慢
3. 多个组件同时使用时，可能产生多个轮询定时器

#### 轮询点2：任务状态查询

**后端接口**: `GET /api/generation/tasks/{task_id}`

```python
@router.get("/tasks/{task_id}", response_model=TaskStatusResponse)
def get_task_status(task_id: str, ...):
    # 从数据库读取任务状态
    db_task = db.query(GenerationTask).filter(...).first()
    
    # 尝试从内存队列同步最新状态
    queue_task = task_queue.get_task(task_id)
    if queue_task:
        # 更新数据库状态
        ...
```

**问题**:
- 数据库和内存队列状态可能不一致
- 高频轮询导致数据库查询压力
- 任务完成后仍可能继续轮询一段时间

### 1.4 混合模式的优缺点分析

#### 优点
- ✅ **冗余保障**: WebSocket 断开时，轮询作为降级方案
- ✅ **兼容性**: 支持不支持 WebSocket 的客户端
- ✅ **调试便利**: 轮询接口便于排查问题

#### 缺点（关键问题）
- ❌ **资源浪费**: WebSocket + 轮询双重消耗
- ❌ **状态不一致**: 数据库、内存队列、前端缓存三层不同步
- ❌ **延迟累积**: 轮询间隔+网络延迟+处理时间 = 5秒+
- ❌ **服务器压力**: 100并发用户 × 0.2 QPS = 20 QPS 持续负载
- ❌ **逻辑复杂**: 前端需同时处理 WebSocket 消息和轮询数据

---

## 二、问题诊断

### 2.1 任务队列无法正常显示的根因分析

#### 问题1：状态同步机制缺失

**根源**: `TaskQueue` 和 `WebSocketManager` 是独立的两个单例

```python
# backend/app/services/task_queue.py
class TaskQueue:
    def _run_task(self, task_id, task_func, args, kwargs):
        # 任务状态变化：PENDING -> PROCESSING -> COMPLETED
        # ❌ 但没有自动触发 WebSocket 推送！
        task_info.status = TaskStatus.COMPLETED
        # 缺少: await ws_manager.broadcast_task_complete(...)
```

**影响**:
- 任务状态只存在内存中，WebSocket 不会主动推送
- 前端依赖轮询才能发现状态变化
- 导致"任务完成了但界面不更新"现象

#### 问题2：异步任务与 WebSocket 推送的脱节

**文件**: `backend/app/routes/generation_v2.py`

```python
# ✅ 同步接口有推送
async def process_image(...):
    result = process_image_with_gemini(...)  # 阻塞执行
    await notify_task_progress(...)  # 完成后推送

# ❌ 异步接口无推送
@router.post("/tasks/async")
async def create_async_task(...):
    task_queue.submit_task(...)  # 提交后就返回
    # 任务在线程池执行，完成时无人知晓！
```

**原因**:
- `ThreadPoolExecutor` 在独立线程执行任务
- 任务执行完成时不在 async 上下文中
- 无法直接调用 `await ws_manager.broadcast_...`

#### 问题3：并发安全问题

```python
# backend/app/services/task_queue.py
with self._lock:  # threading.RLock
    self._tasks[task_id] = task_info

# backend/app/services/websocket_manager.py
async with self._lock:  # asyncio.Lock
    self.active_connections[user_id].add(websocket)
```

**风险**:
- 两个不同类型的锁（threading.RLock vs asyncio.Lock）
- 从线程池调用异步函数需要小心处理事件循环
- 可能导致死锁或消息丢失

#### 问题4：前端订阅机制不完善

```typescript
// src/hooks/useTaskHistory.ts
useEffect(() => {
  const unsubscribeTaskUpdate = subscribe(0, { // 订阅所有任务
    onUpdate: (data, taskId) => handleTaskUpdate(...)
  });
}, [isConnected, subscribe, handleTaskUpdate]);
```

**问题**:
- `handleTaskUpdate` 变化会导致重新订阅
- 依赖项过多，容易触发不必要的重连
- 没有处理"新任务创建"事件

### 2.2 典型失败场景复现

#### 场景A：任务提交后队列不显示

```
时序:
1. 用户提交任务 -> POST /api/v2/tasks/async
2. 后端创建 DB 记录，提交到 TaskQueue
3. 返回 task_id
4. 前端添加到本地 tasks 列表 ❌ 但没有！因为异步提交
5. TaskQueue 开始处理，状态变为 PROCESSING
6. WebSocket 未推送 ❌ 因为 TaskQueue 不知道 WebSocket
7. 5秒后轮询触发 ✅ 终于在列表中显示
```

**用户感知**: 点击生成后等待5秒才看到任务

#### 场景B：任务完成但结果不更新

```
时序:
1. 任务处理中，progress: 80%
2. 任务完成，TaskQueue 设置 status=COMPLETED
3. WebSocket 未推送完成消息 ❌
4. 前端显示 progress: 80% 卡住
5. 轮询间隔到达，查询数据库
6. 数据库状态未更新 ❌ 因为 TaskQueue 只更新内存
7. 用户手动刷新页面 ✅ 终于看到结果
```

**用户感知**: 任务卡在 80%，需要刷新页面

#### 场景C：WebSocket 断开后任务丢失

```
时序:
1. WebSocket 连接正常，用户提交任务
2. 网络波动，WebSocket 断开
3. 前端自动重连，耗时 5-10 秒
4. 此期间任务完成，推送消息丢失 ❌
5. 重连后无法接收历史消息
6. 轮询尚未触发（刚轮询过2秒前）
7. 用户等待数秒后才通过轮询发现结果
```

**用户感知**: 网络抖动后任务状态更新变慢

---

## 三、重构方案

### 3.1 设计目标

1. **实时性**: 任务状态变化 < 500ms 到达前端
2. **可靠性**: 消息丢失率 < 0.1%（通过持久化+重传）
3. **高效性**: 减少 90% 的轮询请求
4. **简洁性**: 前端只需处理 WebSocket，移除轮询逻辑

### 3.2 架构设计

#### 核心思路：将 TaskQueue 与 WebSocket 深度集成

```
                    ┌─────────────────┐
                    │   前端组件      │
                    └────────┬────────┘
                             │ WebSocket
                    ┌────────▼────────┐
                    │  WebSocket      │
                    │  /ws/notifications
                    └────────┬────────┘
                             │
            ┌────────────────┼────────────────┐
            │                │                │
   ┌────────▼──────┐  ┌──────▼──────┐  ┌────▼─────┐
   │ TaskQueue     │  │ WebSocket   │  │ Database │
   │ (内存队列)    ├──►  Manager    │  │          │
   └───────────────┘  └─────────────┘  └──────────┘
         │                    │                │
         │ 1. 状态变化        │ 2. 推送消息   │ 3. 持久化
         └────────────────────┴────────────────┘
                          集成流程
```

#### 关键改进点

**改进1：TaskQueue 回调机制**

```python
class TaskQueue:
    def __init__(self):
        self._status_callbacks: List[Callable] = []
    
    def register_callback(self, callback: Callable):
        """注册状态变化回调"""
        self._status_callbacks.append(callback)
    
    def _notify_status_change(self, task_info: TaskInfo):
        """触发所有注册的回调"""
        for callback in self._status_callbacks:
            try:
                callback(task_info)
            except Exception as e:
                logger.error(f"Callback error: {e}")
    
    def _run_task(self, task_id, task_func, args, kwargs):
        # 状态变化时调用
        task_info.status = TaskStatus.PROCESSING
        self._notify_status_change(task_info)  # ✅ 新增
        
        # ... 执行任务 ...
        
        task_info.status = TaskStatus.COMPLETED
        self._notify_status_change(task_info)  # ✅ 新增
```

**改进2：WebSocket 自动订阅**

```python
# backend/app/main.py 启动时注册
from app.services.task_queue import task_queue
from app.services.websocket_manager import ws_manager

@asynccontextmanager
async def lifespan(app: FastAPI):
    # 注册 TaskQueue 回调
    def on_task_status_change(task_info):
        """TaskQueue 状态变化时自动推送 WebSocket"""
        asyncio.create_task(_push_to_websocket(task_info))
    
    task_queue.register_callback(on_task_status_change)
    
    yield
```

**改进3：线程安全的异步调用桥接**

```python
# backend/app/services/task_bridge.py
import asyncio
from concurrent.futures import ThreadPoolExecutor

class TaskBridge:
    """线程池任务与异步 WebSocket 的桥接器"""
    
    def __init__(self, loop: asyncio.AbstractEventLoop):
        self.loop = loop
    
    def schedule_async(self, coro):
        """从线程池调度异步任务到主事件循环"""
        asyncio.run_coroutine_threadsafe(coro, self.loop)
    
    def notify_task_update(self, task_info: TaskInfo):
        """线程安全的 WebSocket 通知"""
        coro = ws_manager.broadcast_task_update(
            user_id=task_info.user_id,
            data=TaskProgressData(
                task_id=task_info.task_id,
                status=task_info.status.value,
                progress=task_info.progress,
                ...
            )
        )
        self.schedule_async(coro)
```

**改进4：前端移除轮询逻辑**

```typescript
// src/hooks/useTaskHistory.ts
export function useTaskHistory() {
  const [tasks, setTasks] = useState<Task[]>([]);
  const { subscribe, isConnected } = useWebSocketContext();
  
  useEffect(() => {
    // ✅ 仅在首次加载和重连时获取
    fetchTasks();
  }, [isConnected]);  // 依赖项大幅简化
  
  useEffect(() => {
    // ✅ 订阅全局任务更新
    return subscribe(0, {
      onUpdate: (data) => {
        setTasks(prev => updateTaskInList(prev, data));
      },
      onComplete: (data) => {
        setTasks(prev => completeTaskInList(prev, data));
      },
      onFailed: (data) => {
        setTasks(prev => failTaskInList(prev, data));
      }
    });
  }, [subscribe]);
  
  // ❌ 移除轮询逻辑
  // if (autoRefresh || !isConnected) { ... }
}
```

### 3.3 消息可靠性保障

#### 机制1：任务状态持久化

```python
# 每次状态变化同步到数据库
def _notify_status_change(self, task_info: TaskInfo):
    # 1. 触发 WebSocket 推送
    self._push_websocket(task_info)
    
    # 2. 持久化到数据库
    self._sync_to_database(task_info)
```

#### 机制2：重连后全量同步

```typescript
// src/context/WebSocketContext.tsx
ws.onopen = () => {
  setIsConnected(true);
  
  // ✅ 重连后立即拉取最新任务列表
  refetchAllTasks();
  
  // ✅ 发送 sync 消息请求补发未读消息（可选）
  ws.send(JSON.stringify({ type: 'sync', since: lastSyncTimestamp }));
};
```

#### 机制3：消息 ACK 确认（可选，高级功能）

```typescript
// 前端收到消息后发送确认
ws.onmessage = (event) => {
  const message = JSON.parse(event.data);
  
  handleMessage(message);
  
  // 发送 ACK
  ws.send(JSON.stringify({
    type: 'ack',
    message_id: message.id
  }));
};
```

```python
# 后端维护未确认消息队列
async def broadcast_with_ack(user_id, message):
    message['id'] = str(uuid.uuid4())
    message['timestamp'] = datetime.now().isoformat()
    
    # 存入待确认队列
    pending_messages[user_id].append(message)
    
    await ws_manager.send_personal_message(message, user_id)
    
    # 10秒后仍未确认则重发
    asyncio.create_task(check_ack_timeout(user_id, message['id']))
```

---

## 四、代码示例

### 4.1 后端核心实现

#### 示例1：增强的 TaskQueue

```python
# backend/app/services/task_queue.py
import asyncio
from typing import Callable, List, Optional
from app.services.websocket_manager import ws_manager, TaskProgressData

class TaskQueue:
    def __init__(self):
        self._tasks: Dict[str, TaskInfo] = {}
        self._executor = ThreadPoolExecutor(max_workers=4)
        self._lock = threading.RLock()
        self._event_loop: Optional[asyncio.AbstractEventLoop] = None
        self._callbacks: List[Callable[[TaskInfo], None]] = []
    
    def set_event_loop(self, loop: asyncio.AbstractEventLoop):
        """设置主事件循环（用于从线程池调度异步任务）"""
        self._event_loop = loop
    
    def register_callback(self, callback: Callable[[TaskInfo], None]):
        """注册状态变化回调"""
        with self._lock:
            self._callbacks.append(callback)
    
    def _notify_status_change(self, task_info: TaskInfo, event: str = "update"):
        """通知状态变化"""
        # 构建 WebSocket 消息数据
        data = TaskProgressData(
            task_id=int(task_info.task_id),  # 转为数据库 ID
            status=task_info.status.value,
            progress=task_info.progress,
            result_image_url=task_info.result,
            elapsed_time=(
                (datetime.now() - task_info.started_at).total_seconds()
                if task_info.started_at else None
            ),
            estimated_remaining_seconds=self._estimate_remaining(task_info)
        )
        
        # 从线程池调度到主事件循环
        if self._event_loop and not self._event_loop.is_closed():
            if event == "complete":
                coro = ws_manager.broadcast_task_complete(
                    task_info.user_id, 
                    int(task_info.task_id), 
                    data
                )
            elif event == "failed":
                coro = ws_manager.broadcast_task_failed(
                    task_info.user_id,
                    int(task_info.task_id),
                    task_info.error_message or "Unknown error"
                )
            else:  # update
                coro = ws_manager.broadcast_task_update(
                    task_info.user_id, 
                    data
                )
            
            asyncio.run_coroutine_threadsafe(coro, self._event_loop)
    
    def _run_task(self, task_id, task_func, args, kwargs):
        """执行任务（在线程池中运行）"""
        task_info = self._tasks.get(task_id)
        if not task_info:
            return
        
        try:
            # 更新为处理中
            task_info.status = TaskStatus.PROCESSING
            task_info.started_at = datetime.now()
            task_info.progress = 10
            self._notify_status_change(task_info, "update")  # ✅ 推送
            
            # 执行任务
            result = task_func(*args, **kwargs)
            
            # 更新进度: 50%
            task_info.progress = 50
            self._notify_status_change(task_info, "update")  # ✅ 推送
            
            # 完成
            task_info.status = TaskStatus.COMPLETED
            task_info.progress = 100
            task_info.result = result
            task_info.completed_at = datetime.now()
            self._notify_status_change(task_info, "complete")  # ✅ 推送
            
        except Exception as e:
            # 失败
            task_info.status = TaskStatus.FAILED
            task_info.error_message = str(e)
            task_info.completed_at = datetime.now()
            self._notify_status_change(task_info, "failed")  # ✅ 推送
    
    def _estimate_remaining(self, task_info: TaskInfo) -> Optional[int]:
        """估算剩余时间（秒）"""
        if not task_info.started_at or task_info.progress <= 0:
            return None
        
        elapsed = (datetime.now() - task_info.started_at).total_seconds()
        estimated_total = elapsed / (task_info.progress / 100.0)
        remaining = estimated_total - elapsed
        return max(0, int(remaining))
```

#### 示例2：启动时注册事件循环

```python
# backend/app/main.py
import asyncio
from app.services.task_queue import task_queue

@asynccontextmanager
async def lifespan(app: FastAPI):
    # 获取当前事件循环
    loop = asyncio.get_running_loop()
    
    # 将事件循环传递给 TaskQueue
    task_queue.set_event_loop(loop)
    
    logger.info("TaskQueue 已连接到主事件循环")
    
    yield
    
    logger.info("Shutting down...")
```

#### 示例3：数据库同步中间件

```python
# backend/app/services/task_sync.py
from app.database import SessionLocal
from app.models import GenerationTask, TaskStatus as DBTaskStatus

def sync_task_to_database(task_info: TaskInfo):
    """将内存任务状态同步到数据库"""
    db = SessionLocal()
    try:
        db_task = db.query(GenerationTask).filter(
            GenerationTask.id == int(task_info.task_id)
        ).first()
        
        if db_task:
            db_task.status = _convert_status(task_info.status)
            db_task.result_image_url = task_info.result
            db_task.error_message = task_info.error_message
            
            if task_info.completed_at:
                elapsed = (task_info.completed_at - task_info.created_at).total_seconds()
                db_task.elapsed_time = elapsed
            
            db.commit()
            logger.info(f"Task {task_info.task_id} synced to database")
    except Exception as e:
        logger.error(f"Failed to sync task to database: {e}")
        db.rollback()
    finally:
        db.close()

def _convert_status(queue_status: TaskStatus) -> DBTaskStatus:
    """状态转换"""
    mapping = {
        TaskStatus.PENDING: DBTaskStatus.PENDING,
        TaskStatus.PROCESSING: DBTaskStatus.PROCESSING,
        TaskStatus.COMPLETED: DBTaskStatus.COMPLETED,
        TaskStatus.FAILED: DBTaskStatus.FAILED,
        TaskStatus.TIMEOUT: DBTaskStatus.FAILED,
        TaskStatus.CANCELLED: DBTaskStatus.FAILED,
    }
    return mapping.get(queue_status, DBTaskStatus.PENDING)

# 在 lifespan 中注册
@asynccontextmanager
async def lifespan(app: FastAPI):
    task_queue.set_event_loop(asyncio.get_running_loop())
    
    # 注册数据库同步回调
    def on_task_change(task_info):
        # 在线程池执行数据库写入，避免阻塞
        task_queue._executor.submit(sync_task_to_database, task_info)
    
    task_queue.register_callback(on_task_change)
    
    yield
```

### 4.2 前端核心实现

#### 示例1：简化的 useTaskHistory

```typescript
// src/hooks/useTaskHistory.ts
import { useState, useEffect, useCallback } from "react";
import { generationV2API } from "@/integrations/api/client";
import { useAuth } from "./useAuth";
import { useWebSocketContext, TaskProgressData } from "@/context/WebSocketContext";

interface Task {
  id: number;
  status: string;
  result_image_url: string | null;
  // ... 其他字段
}

export function useTaskHistory() {
  const [tasks, setTasks] = useState<Task[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const { user } = useAuth();
  const { isConnected, subscribe } = useWebSocketContext();
  
  // 获取任务列表（仅在初始化和重连时调用）
  const fetchTasks = useCallback(async () => {
    if (!user) {
      setTasks([]);
      return;
    }
    
    setIsLoading(true);
    try {
      const response = await generationV2API.getTasks(0, 50);
      setTasks(response.data.tasks || []);
    } catch (error) {
      console.error("Failed to fetch tasks:", error);
    } finally {
      setIsLoading(false);
    }
  }, [user]);
  
  // 初始加载 + WebSocket 重连时刷新
  useEffect(() => {
    if (user && isConnected) {
      fetchTasks();
    }
  }, [user, isConnected, fetchTasks]);
  
  // WebSocket 消息处理
  useEffect(() => {
    if (!isConnected) return;
    
    // 订阅所有任务更新（taskId = 0）
    const unsubscribe = subscribe(0, {
      onUpdate: (data: TaskProgressData, taskId: number) => {
        setTasks(prev => prev.map(task =>
          task.id === taskId
            ? { ...task, status: data.status }
            : task
        ));
      },
      
      onComplete: (data: TaskProgressData, taskId: number) => {
        setTasks(prev => prev.map(task =>
          task.id === taskId
            ? {
                ...task,
                status: 'completed',
                result_image_url: data.result_image_url || task.result_image_url
              }
            : task
        ));
      },
      
      onFailed: (error: string, taskId: number) => {
        setTasks(prev => prev.map(task =>
          task.id === taskId
            ? { ...task, status: 'failed', error_message: error }
            : task
        ));
      }
    });
    
    return unsubscribe;
  }, [isConnected, subscribe]);
  
  return { tasks, isLoading, refetch: fetchTasks, isConnected };
}
```

#### 示例2：任务提交时的乐观更新

```typescript
// src/hooks/useImageGenerationV2.ts
export function useImageGenerationV2() {
  const { tasks, refetch } = useTaskHistory();
  const { subscribe } = useWebSocketContext();
  
  const submitTask = useCallback(async (file: File, options: GenerationOptions) => {
    try {
      // 1. 提交任务
      const response = await generationV2API.createAsyncTask(file, options);
      const newTaskId = response.data.task_id;
      
      // 2. 乐观更新 UI（立即显示 pending 状态）
      const optimisticTask = {
        id: newTaskId,
        status: 'pending',
        progress: 0,
        created_at: new Date().toISOString(),
        // ...
      };
      
      // 添加到本地任务列表
      setTasks(prev => [optimisticTask, ...prev]);
      
      // 3. 订阅该任务的更新
      const unsubscribe = subscribe(newTaskId, {
        onUpdate: (data) => {
          console.log(`Task ${newTaskId} progress: ${data.progress}%`);
        },
        onComplete: (data) => {
          console.log(`Task ${newTaskId} completed!`);
          unsubscribe();  // 完成后取消订阅
        },
        onFailed: (error) => {
          console.error(`Task ${newTaskId} failed:`, error);
          unsubscribe();
        }
      });
      
      return newTaskId;
    } catch (error) {
      console.error("Failed to submit task:", error);
      throw error;
    }
  }, [subscribe]);
  
  return { submitTask, tasks };
}
```

#### 示例3：增强的 WebSocket 错误处理

```typescript
// src/context/WebSocketContext.tsx
const connect = useCallback(() => {
  if (isConnectingRef.current || !user || !token) return;
  
  const wsUrl = `${WEBSOCKET_CONFIG.url}?token=${token}`;
  isConnectingRef.current = true;
  
  try {
    const ws = new WebSocket(wsUrl);
    
    ws.onopen = () => {
      console.log('[WebSocket] Connected');
      setIsConnected(true);
      reconnectAttemptsRef.current = 0;
      isConnectingRef.current = false;
      
      // ✅ 连接成功后立即同步任务列表
      onConnect?.();
      
      // 启动心跳
      startHeartbeat();
    };
    
    ws.onmessage = (event) => {
      try {
        const message: WebSocketMessage = JSON.parse(event.data);
        
        // 处理心跳
        if (message.type === 'pong') {
          return;
        }
        
        // 更新最后消息
        setLastMessage(message);
        
        // 通知订阅者
        notifySubscribers(message);
        
      } catch (error) {
        console.error('[WebSocket] Failed to parse message:', error);
      }
    };
    
    ws.onerror = (error) => {
      console.error('[WebSocket] Error:', error);
      onError?.(error);
    };
    
    ws.onclose = (event) => {
      console.log(`[WebSocket] Closed: code=${event.code}, reason=${event.reason}`);
      setIsConnected(false);
      isConnectingRef.current = false;
      wsRef.current = null;
      
      // 停止心跳
      stopHeartbeat();
      
      // ✅ 自动重连（指数退避）
      if (reconnectAttemptsRef.current < WEBSOCKET_CONFIG.maxRetries) {
        const delay = Math.min(
          1000 * Math.pow(2, reconnectAttemptsRef.current),
          30000  // 最大30秒
        );
        
        console.log(`[WebSocket] Reconnecting in ${delay}ms...`);
        reconnectAttemptsRef.current++;
        
        setTimeout(() => {
          connect();
        }, delay);
      } else {
        console.error('[WebSocket] Max reconnect attempts reached');
        onDisconnect?.();
      }
    };
    
    wsRef.current = ws;
  } catch (error) {
    console.error('[WebSocket] Failed to create connection:', error);
    isConnectingRef.current = false;
  }
}, [user, token, onConnect, onDisconnect, onError]);
```

---

## 五、迁移风险点

### 5.1 连接管理风险

#### 风险1：连接泄漏

**场景**: 用户快速切换页面，WebSocket 未正确关闭

**预防**:
```typescript
// 确保组件卸载时清理连接
useEffect(() => {
  connect();
  
  return () => {
    disconnect();  // ✅ 必须调用
    unsubscribeAll();
  };
}, []);
```

#### 风险2：重连风暴

**场景**: 服务器重启，1000个客户端同时重连

**预防**:
```typescript
// 添加随机抖动
const jitter = Math.random() * 1000;
const delay = baseDelay + jitter;

setTimeout(() => connect(), delay);
```

**后端限流**:
```python
from slowapi import Limiter

limiter = Limiter(key_func=get_remote_address)

@app.websocket("/ws/notifications")
@limiter.limit("10/minute")  # 限制每分钟10次连接
async def websocket_notifications(...):
    ...
```

### 5.2 消息可靠性风险

#### 风险3：消息丢失

**场景**:
1. WebSocket 断开时的消息
2. 服务器重启时的内存任务
3. 客户端未监听时的消息

**解决方案**:

**方案A: 消息持久化（推荐）**
```python
# 将关键消息写入 Redis 或数据库
await redis.lpush(f"user:{user_id}:messages", json.dumps(message))
await redis.expire(f"user:{user_id}:messages", 3600)  # 保留1小时

# 客户端重连时拉取
@app.post("/api/messages/sync")
async def sync_messages(since: datetime, user: User = Depends(get_current_user)):
    messages = await redis.lrange(f"user:{user.id}:messages", 0, -1)
    return {"messages": [json.loads(m) for m in messages]}
```

**方案B: 幂等性设计**
```python
# 消息包含唯一 ID
message = {
    "id": str(uuid.uuid4()),
    "type": "task_complete",
    "task_id": 123,
    "timestamp": datetime.now().isoformat(),
    ...
}

# 前端去重
const processedMessageIds = new Set<string>();

ws.onmessage = (event) => {
  const message = JSON.parse(event.data);
  
  if (processedMessageIds.has(message.id)) {
    console.log("Duplicate message, ignoring");
    return;
  }
  
  processedMessageIds.add(message.id);
  handleMessage(message);
};
```

#### 风险4：消息顺序错乱

**场景**: 网络延迟导致后发送的消息先到达

**解决方案**:
```typescript
// 使用时间戳排序
const updateTask = (newData: TaskProgressData) => {
  setTasks(prev => prev.map(task => {
    if (task.id !== newData.task_id) return task;
    
    // ✅ 只接受更新的数据
    const existingTime = new Date(task.updated_at).getTime();
    const newTime = new Date(newData.updated_at).getTime();
    
    if (newTime < existingTime) {
      console.warn("Ignoring outdated message");
      return task;
    }
    
    return { ...task, ...newData };
  }));
};
```

### 5.3 性能风险

#### 风险5：消息积压

**场景**: 任务密集创建，WebSocket 发送速度跟不上

**监控**:
```python
# 监控待发送队列长度
async def broadcast_task_update(user_id, data):
    connections = self.active_connections.get(user_id, set())
    
    for ws in connections:
        queue_size = ws._send_queue.qsize()  # 内部队列
        
        if queue_size > 100:
            logger.warning(f"WebSocket queue overflow: {queue_size}")
            # 可选：跳过非关键消息
            if data.status not in ['completed', 'failed']:
                continue
        
        await ws.send_json(message)
```

**优化**: 消息合并
```python
# 短时间内的多次 progress 更新合并为一次
from collections import defaultdict
import asyncio

class MessageBatcher:
    def __init__(self):
        self._pending: Dict[int, TaskProgressData] = {}
        self._lock = asyncio.Lock()
    
    async def add(self, user_id: int, data: TaskProgressData):
        async with self._lock:
            # 覆盖旧的 progress 消息
            key = (user_id, data.task_id)
            self._pending[key] = data
    
    async def flush(self):
        """每100ms批量发送"""
        while True:
            await asyncio.sleep(0.1)
            
            async with self._lock:
                for (user_id, task_id), data in self._pending.items():
                    await ws_manager.broadcast_task_update(user_id, data)
                self._pending.clear()
```

#### 风险6：内存泄漏

**场景**: `TaskQueue._tasks` 字典无限增长

**解决方案**:
```python
# 已有的 cleanup_old_tasks，确保正常运行
def _start_cleanup(self):
    async def periodic_cleanup():
        while True:
            await asyncio.sleep(3600)  # 每小时
            count = self.cleanup_old_tasks(max_age_hours=24)
            logger.info(f"Cleaned {count} old tasks")
    
    # ✅ 在主事件循环启动
    loop = asyncio.get_running_loop()
    loop.create_task(periodic_cleanup())
```

**额外监控**:
```python
@app.get("/admin/queue/stats")
async def queue_stats(admin: User = Depends(require_admin)):
    return {
        "total_tasks": len(task_queue._tasks),
        "active_connections": ws_manager.get_total_connections(),
        "memory_usage_mb": psutil.Process().memory_info().rss / 1024 / 1024
    }
```

### 5.4 鉴权风险

#### 风险7：Token 过期

**场景**: 长连接期间 JWT token 过期（如1小时后）

**解决方案A**: Token 刷新机制
```typescript
// 前端定期刷新 token
useEffect(() => {
  const refreshInterval = setInterval(async () => {
    try {
      const newToken = await authAPI.refreshToken();
      localStorage.setItem('token', newToken);
      
      // 重连 WebSocket 以使用新 token
      disconnect();
      setTimeout(() => connect(), 1000);
    } catch (error) {
      console.error("Failed to refresh token", error);
    }
  }, 50 * 60 * 1000);  // 50分钟刷新一次（token有效期1小时）
  
  return () => clearInterval(refreshInterval);
}, []);
```

**解决方案B**: 长期 token（推荐）
```python
# WebSocket token 使用更长的过期时间
def create_ws_token(user_id: int):
    return jwt.encode(
        {
            "sub": str(user_id),
            "exp": datetime.utcnow() + timedelta(days=7)  # 7天有效期
        },
        settings.SECRET_KEY,
        algorithm=settings.ALGORITHM
    )
```

#### 风险8：跨域问题

**场景**: WebSocket 从不同域连接（如 Tauri 应用）

**配置**:
```python
# 允许 WebSocket 跨域
@app.websocket("/ws/notifications")
async def websocket_notifications(websocket: WebSocket, ...):
    # 检查 Origin
    origin = websocket.headers.get("origin", "")
    
    allowed_origins = [
        "http://localhost:34345",
        "tauri://localhost",
        "http://129.211.218.135"
    ]
    
    if origin not in allowed_origins:
        await websocket.close(code=4003, reason="Origin not allowed")
        return
    
    await websocket.accept()
```

### 5.5 降级兼容风险

#### 风险9：老客户端兼容

**场景**: 部分用户浏览器不支持 WebSocket

**解决方案**: 特性检测 + 降级
```typescript
// src/hooks/useWebSocket.ts
export function useWebSocket(options: UseWebSocketOptions) {
  const [supportsWebSocket] = useState(() => 'WebSocket' in window);
  
  useEffect(() => {
    if (!supportsWebSocket) {
      console.warn("WebSocket not supported, falling back to polling");
      // 启用轮询降级
      enablePollingFallback();
      return;
    }
    
    connect();
  }, [supportsWebSocket]);
  
  return {
    isConnected: supportsWebSocket ? isConnected : false,
    usesPolling: !supportsWebSocket,
    ...
  };
}
```

**后端兼容**: 保留轮询接口但限流
```python
@router.get("/tasks/{task_id}/status")
@limiter.limit("10/minute")  # 限制轮询频率
async def get_task_status(task_id: int, ...):
    """仅用于不支持 WebSocket 的客户端"""
    ...
```

---

## 六、迁移步骤建议

### 6.1 分阶段迁移

#### 阶段1：完善 WebSocket 推送（1周）
- [x] 已有 WebSocket 基础设施
- [ ] TaskQueue 集成事件循环
- [ ] 注册状态变化回调
- [ ] 数据库同步中间件
- [ ] 单元测试 + 集成测试

#### 阶段2：前端优化（3天）
- [ ] 移除轮询定时器
- [ ] 简化 useTaskHistory 依赖
- [ ] 添加乐观更新
- [ ] 增强错误处理

#### 阶段3：灰度发布（1周）
- [ ] 10% 用户启用纯 WebSocket
- [ ] 监控错误率、延迟
- [ ] 对比轮询 vs WebSocket 指标
- [ ] 修复发现的问题

#### 阶段4：全量切换（3天）
- [ ] 100% 用户切换
- [ ] 关闭轮询接口（或限流到极低）
- [ ] 清理冗余代码

### 6.2 回滚预案

**触发条件**:
- WebSocket 连接成功率 < 95%
- 任务更新延迟 > 5秒（P99）
- 错误率 > 1%

**回滚步骤**:
1. 重新启用轮询定时器
2. 调整轮询间隔到 3 秒
3. 降级 WebSocket 为可选功能
4. 发布紧急修复版本

**代码开关**:
```typescript
// src/config/index.ts
export const FEATURE_FLAGS = {
  useWebSocketOnly: import.meta.env.VITE_USE_WS_ONLY === 'true',
  pollingInterval: parseInt(import.meta.env.VITE_POLLING_INTERVAL || '5000'),
};

// 使用
if (FEATURE_FLAGS.useWebSocketOnly && isConnected) {
  // 仅 WebSocket
} else {
  // WebSocket + 轮询降级
  startPolling(FEATURE_FLAGS.pollingInterval);
}
```

---

## 七、监控指标

### 7.1 关键指标

| 指标 | 目标 | 监控方式 |
|-----|------|---------|
| WebSocket 连接成功率 | > 99% | `ws_manager.get_total_connections()` |
| 消息推送延迟 | P50 < 100ms, P99 < 500ms | 时间戳对比 |
| 消息丢失率 | < 0.1% | 序号检测 |
| 重连次数 | < 5次/小时/用户 | 前端埋点 |
| 服务器 CPU | < 50% | Prometheus |
| WebSocket 内存占用 | < 1MB/连接 | `psutil` |

### 7.2 日志埋点

```python
# 后端
logger.info("websocket_connect", extra={
    "user_id": user_id,
    "ip": client_ip,
    "user_agent": user_agent
})

logger.info("task_status_change", extra={
    "task_id": task_id,
    "old_status": old_status,
    "new_status": new_status,
    "elapsed_ms": elapsed_ms
})
```

```typescript
// 前端
console.log('[Metrics] WebSocket latency:', {
  messageId: message.id,
  sentAt: message.timestamp,
  receivedAt: Date.now(),
  latency: Date.now() - new Date(message.timestamp).getTime()
});
```

---

## 八、参考资料

### 8.1 相关文档

- [FastAPI WebSocket 文档](https://fastapi.tiangolo.com/advanced/websockets/)
- [MDN WebSocket API](https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket)
- [RFC 6455 - WebSocket Protocol](https://tools.ietf.org/html/rfc6455)

### 8.2 项目文件清单

**核心文件**:
- `backend/app/services/task_queue.py` - 任务队列
- `backend/app/services/websocket_manager.py` - WebSocket 管理器
- `backend/app/main.py` - WebSocket 端点
- `backend/app/routes/generation_v2.py` - V2 路由（含推送调用）
- `src/context/WebSocketContext.tsx` - 前端 WebSocket 上下文
- `src/hooks/useTaskHistory.ts` - 任务历史 Hook
- `backend/tests/test_websocket.py` - WebSocket 测试用例

**待修改文件**:
- `backend/app/services/task_queue.py` - 添加回调机制
- `backend/app/main.py` - 注册事件循环
- `src/hooks/useTaskHistory.ts` - 移除轮询逻辑

---

## 九、总结与建议

### 9.1 当前评估

**现有实现成熟度**: ⭐⭐⭐⭐ (4/5)

- ✅ WebSocket 基础设施完善
- ✅ 前端订阅机制健全
- ✅ 自动重连已实现
- ❌ TaskQueue 与 WebSocket 未集成
- ❌ 仍依赖轮询作为主要机制

### 9.2 核心建议

1. **优先级最高**: 将 `TaskQueue` 集成到主事件循环，实现自动推送
2. **快速见效**: 移除前端轮询定时器，减少 90% 无效请求
3. **稳定性保障**: 实现消息持久化 + 重连同步
4. **长期优化**: 添加监控告警，持续优化延迟

### 9.3 预期收益

| 方面 | 改进前 | 改进后 | 提升 |
|-----|-------|-------|------|
| 任务更新延迟 | 5秒 | 0.5秒 | **90%** |
| 服务器 QPS | 100 req/s | 10 req/s | **90%** |
| 用户体验评分 | 3/5 | 4.5/5 | **50%** |
| 代码复杂度 | 高（双机制） | 中（单机制） | **简化** |

### 9.4 下一步行动

1. **本周**:
   - [ ] 完成 `TaskQueue` 事件循环集成
   - [ ] 编写集成测试用例
   - [ ] Code Review

2. **下周**:
   - [ ] 前端移除轮询逻辑
   - [ ] 灰度发布 10%
   - [ ] 监控数据分析

3. **月度目标**:
   - [ ] 全量切换到 WebSocket
   - [ ] 优化消息传输性能
   - [ ] 文档更新完成

---

## 附录

### A. 常见问题

**Q1: WebSocket 断开后任务状态会丢失吗？**  
A: 不会。任务状态持久化在数据库中，重连后通过 `fetchTasks()` 全量同步。

**Q2: 是否需要完全移除轮询？**  
A: 建议保留作为降级方案，但默认关闭。通过特性开关控制。

**Q3: 如何处理高并发场景？**  
A: 使用消息批处理、连接池、水平扩展（Nginx + 多后端实例 + Redis Pub/Sub）。

**Q4: 移动端网络不稳定怎么办？**  
A: 增强重连策略（最大重试次数、指数退避），并在断连期间缓存消息。

### B. 技术栈版本

- Python: 3.10+
- FastAPI: 0.110+
- React: 18.x
- TypeScript: 5.x
- WebSocket Protocol: RFC 6455

### C. 联系方式

如有疑问，请联系开发团队或参考以下资源：
- 项目 README: `./README.md`
- API 文档: `http://localhost:8002/docs`
- 测试文档: `./docs/V2接口测试文档.md`

---

**文档版本**: v1.0  
**最后更新**: 2026-01-08
