---
description: 帕金森定律 - 工作会扩展填满所有可用时间，设定紧凑截止日期
globs: ["**/*.py", "**/*.ts", "**/*.tsx", "**/*.js", "**/*.jsx", "**/*.md"]
alwaysApply: true
---

# 帕金森定律 (Parkinson's Law)

## 核心思想

"工作会扩展，直到填满所有可用的时间。" 这意味着如果没有明确的截止日期和范围限制，任务会无限膨胀，导致效率低下和过度工程。

## 在本项目中的应用规则

### 1. 任务时间估算

#### 设定紧凑但合理的截止日期

```python
# ✅ 好的做法：设定明确的时间限制
# 任务：实现直播报告生成功能
# 时间估算：2天（16小时）
# 截止日期：2024-01-15 18:00

# 分解任务：
# - 基础报告生成：4小时
# - 数据聚合逻辑：4小时
# - API 接口：2小时
# - 测试和调试：4小时
# - 文档：2小时

# ❌ 避免：模糊的时间估算
# 任务：实现直播报告生成功能
# 时间：尽快完成
# 结果：可能拖到1周甚至更久
```

#### 使用时间盒（Time Boxing）

```python
# ✅ 好的做法：为每个功能设定时间盒
class FeatureDevelopment:
    """功能开发时间盒"""
    
    TIME_BOXES = {
        "基础功能": "4小时",
        "增强功能": "2小时",
        "测试": "2小时",
        "文档": "1小时",
        "代码审查": "1小时"
    }
    
    def develop_feature(self, feature_name: str):
        """开发功能，严格控制在时间盒内"""
        start_time = time.time()
        
        # 基础功能：4小时
        if time.time() - start_time < 4 * 3600:
            self._implement_basic(feature_name)
        else:
            logger.warning("基础功能时间盒已用完，停止开发")
            return
        
        # 如果还有时间，添加增强功能
        remaining_time = 10 * 3600 - (time.time() - start_time)
        if remaining_time > 2 * 3600:
            self._add_enhancements(feature_name)
```

### 2. 防止范围蔓延（Scope Creep）

#### 明确功能边界

```python
# ✅ 好的做法：明确功能范围
class LiveReportService:
    """
    直播报告服务 - MVP 版本
    
    范围：
    - ✅ 生成基础文本报告
    - ✅ 包含会话摘要和关键数据
    - ❌ 不包含图表生成（后续迭代）
    - ❌ 不包含多格式导出（后续迭代）
    - ❌ 不包含自定义模板（后续迭代）
    """
    
    def generate_report(self, session_id: int) -> dict:
        """生成基础报告 - 严格限制在 MVP 范围内"""
        # 只实现核心功能
        return {
            "summary": self._generate_summary(session_id),
            "key_metrics": self._calculate_metrics(session_id)
        }
    
    # 不在 MVP 范围内的功能，明确标记为后续实现
    # def generate_chart_report(self, session_id: int):
    #     """生成带图表的报告 - 后续迭代"""
    #     pass

# ❌ 避免：功能范围不明确
class LiveReportService:
    """直播报告服务 - 可能包含任何功能"""
    
    def generate_report(self, session_id: int):
        # 开始实现基础功能
        # 然后添加图表
        # 然后添加导出
        # 然后添加自定义模板
        # ... 永远做不完
        pass
```

#### 使用功能清单

```python
# ✅ 好的做法：使用功能清单明确范围
FEATURE_CHECKLIST = {
    "MVP_v1": {
        "must_have": [
            "基础报告生成",
            "文本格式输出",
            "关键指标计算"
        ],
        "nice_to_have": [
            "图表生成",
            "多格式导出",
            "自定义模板"
        ],
        "future": [
            "AI 分析",
            "实时报告",
            "批量处理"
        ]
    }
}

def implement_feature(feature_name: str):
    """实现功能 - 只实现 must_have 列表中的"""
    if feature_name not in FEATURE_CHECKLIST["MVP_v1"]["must_have"]:
        logger.warning(f"{feature_name} 不在 MVP 范围内，推迟实现")
        return
    # 实现功能
```

### 3. 代码审查时间限制

#### 设定审查时间盒

```python
# ✅ 好的做法：代码审查也有时间限制
class CodeReview:
    """代码审查 - 设定时间限制"""
    
    REVIEW_TIME_LIMIT = 30 * 60  # 30分钟
    
    def review_code(self, pr_id: int):
        """审查代码 - 在时间限制内完成"""
        start_time = time.time()
        
        # 重点审查：
        # 1. 核心逻辑（10分钟）
        # 2. 错误处理（5分钟）
        # 3. 测试覆盖（5分钟）
        # 4. 代码风格（5分钟）
        # 5. 性能问题（5分钟）
        
        if time.time() - start_time > self.REVIEW_TIME_LIMIT:
            logger.warning("审查时间已用完，提交初步意见")
            return self._submit_preliminary_review(pr_id)
        
        return self._submit_full_review(pr_id)
```

### 4. 重构时间限制

#### 避免无限重构

```python
# ✅ 好的做法：重构也有时间限制
def refactor_service(service_name: str, time_limit_hours: int = 4):
    """重构服务 - 设定时间限制"""
    start_time = time.time()
    time_limit_seconds = time_limit_hours * 3600
    
    # 重构步骤：
    # 1. 识别问题（30分钟）
    # 2. 设计新结构（1小时）
    # 3. 实施重构（2小时）
    # 4. 测试验证（30分钟）
    
    if time.time() - start_time > time_limit_seconds:
        logger.warning("重构时间已用完，保存当前进度")
        # 保存中间状态，下次继续
        return
    
    # 完成重构

# ❌ 避免：无限重构
def refactor_service(service_name: str):
    """重构服务 - 没有时间限制"""
    # 开始重构
    # 发现更多问题
    # 继续重构
    # 发现更多问题
    # ... 永远重构不完
    pass
```

### 5. 会议和讨论时间限制

#### 设定会议时间盒

```python
# ✅ 好的做法：技术讨论也有时间限制
class TechnicalDiscussion:
    """技术讨论 - 设定时间限制"""
    
    DISCUSSION_TIME_LIMIT = 60 * 60  # 1小时
    
    def discuss_architecture(self, topic: str):
        """讨论架构 - 在时间限制内做出决策"""
        start_time = time.time()
        
        # 讨论流程：
        # 1. 问题陈述（10分钟）
        # 2. 方案讨论（30分钟）
        # 3. 决策（10分钟）
        # 4. 行动计划（10分钟）
        
        if time.time() - start_time > self.DISCUSSION_TIME_LIMIT:
            logger.warning("讨论时间已用完，做出临时决策")
            # 做出临时决策，后续可以调整
            return self._make_temporary_decision(topic)
        
        return self._make_final_decision(topic)
```

### 6. 项目里程碑设定

#### 明确的里程碑和检查点

```python
# ✅ 好的做法：设定明确的里程碑
PROJECT_MILESTONES = {
    "MVP_v1": {
        "deadline": "2024-01-20",
        "features": [
            "基础直播录制",
            "简单报告生成",
            "用户认证"
        ],
        "no_scope_creep": True  # 不允许范围蔓延
    },
    "v1.1": {
        "deadline": "2024-02-10",
        "features": [
            "增强报告功能",
            "数据分析"
        ]
    }
}

def check_milestone(milestone_name: str):
    """检查里程碑 - 严格按时间执行"""
    milestone = PROJECT_MILESTONES[milestone_name]
    
    if datetime.now() > datetime.fromisoformat(milestone["deadline"]):
        logger.error(f"里程碑 {milestone_name} 已过期")
        # 停止添加新功能，只完成已承诺的功能
        return
    
    # 检查是否在范围内
    if milestone.get("no_scope_creep"):
        # 严格限制在已定义的功能内
        pass
```

### 7. 开发任务分解

#### 将大任务分解为小任务

```python
# ✅ 好的做法：将大任务分解为有时间限制的小任务
def break_down_task(large_task: str) -> List[dict]:
    """将大任务分解为小任务"""
    tasks = [
        {
            "name": "设计接口",
            "duration": "2小时",
            "deadline": "今天 18:00"
        },
        {
            "name": "实现核心逻辑",
            "duration": "4小时",
            "deadline": "明天 12:00"
        },
        {
            "name": "编写测试",
            "duration": "2小时",
            "deadline": "明天 18:00"
        },
        {
            "name": "代码审查",
            "duration": "1小时",
            "deadline": "后天 10:00"
        }
    ]
    return tasks

# ❌ 避免：模糊的大任务
def large_task():
    """大任务 - 没有分解，没有时间限制"""
    # 可能永远做不完
    pass
```

### 8. 防止过度工程

#### 在时间限制内完成

```python
# ✅ 好的做法：在时间限制内完成，避免过度工程
def implement_feature(feature_name: str, time_limit: int = 4):
    """实现功能 - 时间限制防止过度工程"""
    start_time = time.time()
    
    # 实现最简单的可行方案
    simple_solution = implement_simple_solution(feature_name)
    
    # 如果还有时间，可以优化
    remaining_time = time_limit * 3600 - (time.time() - start_time)
    if remaining_time > 3600:
        # 有时间才优化
        optimized_solution = optimize_solution(simple_solution)
        return optimized_solution
    
    return simple_solution

# ❌ 避免：没有时间限制，容易过度工程
def implement_feature(feature_name: str):
    """实现功能 - 可能过度工程"""
    # 设计完美的架构
    # 实现所有可能的功能
    # 优化所有细节
    # ... 永远做不完
    pass
```

## 实践建议

### 1. 使用时间追踪

```python
# 记录实际花费的时间
TIME_TRACKING = {
    "task_name": {
        "estimated": "4小时",
        "actual": "6小时",
        "variance": "+50%"
    }
}

# 根据历史数据调整估算
def estimate_task_time(task_name: str) -> float:
    """根据历史数据估算任务时间"""
    if task_name in TIME_TRACKING:
        historical_avg = calculate_average(TIME_TRACKING[task_name]["actual"])
        # 增加20%的缓冲（考虑霍夫施塔特定律）
        return historical_avg * 1.2
    return default_estimate(task_name)
```

### 2. 设定每日目标

```python
# ✅ 好的做法：设定每日明确目标
DAILY_GOALS = {
    "2024-01-15": [
        "完成报告生成核心逻辑",
        "编写基础测试",
        "代码审查PR #123"
    ]
}

def check_daily_progress(date: str):
    """检查每日进度"""
    goals = DAILY_GOALS.get(date, [])
    completed = check_completed_tasks(goals)
    
    if len(completed) < len(goals) * 0.8:  # 完成度低于80%
        logger.warning(f"{date} 目标完成度不足，需要调整")
```

## 与项目其他原则的配合

- **与 YAGNI 配合**：时间限制防止实现"将来可能有用"的功能
- **与 KISS 配合**：时间限制鼓励简单直接的实现
- **与霍夫施塔特定律配合**：设定紧凑但合理的截止日期

## 代码审查检查点

在代码审查时，检查：
1. 任务是否有明确的截止日期？
2. 功能范围是否明确？
3. 是否有范围蔓延的迹象？
4. 时间估算是否合理？
5. 是否有过度工程的迹象？

## 记住

**没有截止日期的任务会永远做不完。**

- 为每个任务设定明确的、紧凑的截止日期
- 明确功能范围，防止范围蔓延
- 将大任务分解为有时间限制的小任务
- 使用时间盒控制开发时间
- 定期回顾和调整时间估算

**时间限制是效率的朋友，不是敌人。**